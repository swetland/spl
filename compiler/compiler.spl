// Copyright 2023, Brian Swetland <swetland@frotz.net>
// Licensed under the Apache License, Version 2.0.

// utility functions

fn error_begin() i32 {
	writes(2, "\n");
	writes(2, "error: ");
	return 2;
}

fn error_end() {
	writes(2, "\n");
	os_exit(1);
}

fn strneq(s1 str, s2 str, len u32) i32 {
	var n u32 = 0;
	while (n < len) {
		if (s1[n] != s2[n]) {
			return 0;
		}
		n++;
	}
	return 1;
}

fn strcpyn(dst str, src str, len u32) {
	var n u32 = 0;
	while (n < len) {
		dst[n] = src[n];
		n++;
	}
}

// ================================================================
// data types

struct String {
	next *String,
	len u32,
	text [256]u8,
};

enum SymbolKind {
	SYMBOL_VAR,
	SYMBOL_FLD, // struct field
	SYMBOL_PTR, // struct *field
	SYMBOL_DEF, // enum
	SYMBOL_FN,
};

struct Symbol {
	next *Symbol,
	name *String,
	type *Type,
	kind SymbolKind,
};

enum ScopeKind {
	SCOPE_GLOBAL,
	SCOPE_FUNC,
	SCOPE_BLOCK,
	SCOPE_LOOP,
	SCOPE_STRUCT,
};

struct Scope {
	parent *Scope,
	first *Symbol,
	last *Symbol,
	kind ScopeKind,
};

enum TypeKind {
	TYPE_VOID,
	TYPE_BOOL,
	TYPE_U8,
	TYPE_U32,
	TYPE_NIL,
	TYPE_POINTER,
	TYPE_ARRAY,
	TYPE_SLICE,
	TYPE_STR,
	TYPE_STRUCT,
	TYPE_FUNC,
	TYPE_ENUM,
	TYPE_UNDEFINED,
};

struct Type {
	next *Type,
	name *String,
	of *Type,        // for slice, array, ptr
	fields *Symbol,  // for struct
	kind TypeKind,
	count u32,
};

// ================================================================
// lexical scanner tokens

// token classes (tok & tcMASK)
enum TokenClass{
	tcRELOP = 0x08, tcADDOP = 0x10, tcMULOP = 0x18,
	tcAEQOP = 0x20, tcMEQOP = 0x28, tcMASK = 0xF8,
};

enum Token {
	// EndMarks, Braces, Brackets Parens
	tEOF, tEOL, tOBRACE, tCBRACE, tOBRACK, tCBRACK, tOPAREN, tCPAREN,
	// RelOps (do not reorder)
	tEQ, tNE, tLT, tLE, tGT, tGE, tx0E, tx0F,
	// AddOps (do not reorder)
	tPLUS, tMINUS, tPIPE, tCARET, tx14, tx15, tx16, tx17,
	// MulOps (do not reorder)
	tSTAR, tSLASH, tPERCENT, tAMP, tLEFT, tRIGHT, tx1E, tx1F,
	// AsnOps (do not reorder)
	tADDEQ, tSUBEQ, tOREQ, tXOREQ, tx24, tx25, tx26, tx27,
	tMULEQ, tDIVEQ, tMODEQ, tANDEQ, tLSEQ, tRSEQ, t2E, t2F,
	// Various, UnaryNot, LogicalOps,
	tSEMI, tCOLON, tDOT, tCOMMA, tNOT, tAND, tOR, tBANG,
	tASSIGN, tINC, tDEC,
	tAT,
	// Keywords
	tNEW, tFN, tSTRUCT, tVAR, tENUM,
	tIF, tELSE, tWHILE,
	tBREAK, tCONTINUE, tRETURN,
	tFOR, tSWITCH, tCASE,
	tTRUE, tFALSE, tNIL,
	tIDN, tNUM, tSTR,
	// used internal to the lexer but never returned
	tSPC, tINV, tDQT, tSQT, tMSC,
};

var tnames []str = {
	"<EOF>", "<EOL>", "{",  "}",  "[",   "]",   "(",   ")",
	"==",    "!=",    "<",  "<=", ">",   ">=",  "",    "",
	"+",     "-",     "|",  "^",  "",    "",    "",    "",
	"*",     "/",     "%",  "&",  "<<",  ">>",  "",    "",
	"+=",    "-=",    "|=", "^=", "",    "",    "",    "",
	"*=",    "/=",    "%=", "&=", "<<=", ">>=", "",    "",
	";",     ":",     ".",  ",",  "~",   "&&",  "||",  "!",
	"=",     "++",    "--",
	"@",
	"new", "fn", "struct", "var", "enum",
	"if", "else", "while",
	"break", "continue", "return",
	"for", "switch", "case",
	"true", "false", "nil",
	"<ID>", "<NUM>", "<STR>",
	"<SPC>", "<INV>", "<DQT>", "<SQT>", "<MSC>",
};


// ================================================================
// lexer / parser / compiler context

struct Context {
	stringlist *String,	// intern table

	linenumber u32,		// line number of most recent line
	lineoffset u32,		// position of start of most recent line
	byteoffset u32,		// position of the most recent character
	flags u32,
	cc u32,			// scanner: next character

	tok Token,		// most recent token
	num u32,		// for tNUM
	tmp [256]u8,		// for tIDN, tSTR
	ident *String,		// for tSTR

	typelist *Type,		// all types
	scope *Scope,		// top of Scope stack
	cur_fn *Scope,		// args of fn being parsed
	global *Scope,		// the global scope

	idn_if *String,		// identifier strings
	idn_fn *String,
	idn_for *String,
	idn_var *String,
	idn_nil *String,
	idn_new *String,
	idn_case *String,
	idn_else *String,
	idn_enum *String,
	idn_true *String,
	idn_break *String,
	idn_while *String,
	idn_false *String,
	idn_switch *String,
	idn_struct *String,
	idn_return *String,
	idn_continue *String,
};

var ctx Context;

fn string_make(text str, len u32) String {
	var s String = ctx.stringlist;
	while (s != nil) {
		if (s.len == len) && strneq(text, s.text, len) {
			return s;
		}
		s = s.next;
	}
	s = new(String);
	s.len = len;
	strcpyn(s.text, text, len + 1);
	s.next = ctx.stringlist;
	ctx.stringlist = s;
	return s;
}

fn scope_push(kind ScopeKind) Scope {
	var scope Scope = new(Scope);
	scope.first = nil;
	scope.last = nil;
	scope.parent = ctx.scope;
	scope.kind = kind;
	ctx.scope = scope;
	return scope;
}

fn scope_pop() Scope {
	var scope Scope = ctx.scope;
	ctx.scope = scope.parent;
	return scope;
}

fn scope_find(kind ScopeKind) Scope {
	var scope Scope = ctx.scope;
	while (scope != nil) {
		if (scope.kind == kind) {
			return scope;
		}
		scope = scope.parent;
	}
	return nil;
}

fn symbol_find_in(name String, scope Scope) Symbol {
	var sym Symbol = scope.first;
	while (sym != nil) {
		if (sym.name == name) {
			return sym;
		}
		sym = sym.next;
	}
	return nil;
}

// find the first surrounding scope of a specified kind
fn symbol_find(name String) Symbol {
	var scope Scope = ctx.scope;
	while (scope != nil) {
		var sym Symbol = symbol_find_in(name, scope);
		if (sym != nil) {
			return sym;
		}
		scope = scope.parent;
	}
	return nil;
}

fn symbol_make_in_scope(name String, type Type, scope Scope) Symbol {
	var sym Symbol = new(Symbol);
	sym.name = name;
	sym.type = type;
	sym.next = nil;
	sym.kind = SYMBOL_VAR;
	if (scope.first == nil) {
		scope.first = sym;
	} else {
		scope.last.next = sym;
	}
	scope.last = sym;
	return sym;
}

fn symbol_make_global(name String, type Type) Symbol {
	return symbol_make_in_scope(name, type, ctx.global);
}

fn symbol_make(name String, type Type) Symbol {
	return symbol_make_in_scope(name, type, ctx.scope);
}

fn type_make(name String, kind TypeKind, of Type, fields Symbol, count u32) Type {
	var type Type = new(Type);
	type.name = name;
	type.of = of;
	type.fields = fields;
	type.kind = kind;
	type.count = count;
	if (name != nil) {
		type.next = ctx.typelist;
		ctx.typelist = type;
	} else {
		type.next = nil;
	}
	return type;
}

fn type_find(name String) Type {
	var t Type = ctx.typelist;
	while (t != nil) {
		if (t.name == name) {
			return t;
		}
		t = t.next;
	}
	return nil;
}

fn type_find_field(type Type, name String) Symbol {
	if (type.kind != TYPE_STRUCT) {
		error("not a struct");
	}
	var s Symbol = type.fields;
	while(s != nil) {
		if (s.name == name) {
			return s;
		}
		s = s.next;
	}
	error("struct has no such field '", @str name.text, "'");
	return nil;
}


fn ctx_init() {
	ctx = new(Context);

	ctx.idn_if       = string_make("if", 2);
	ctx.idn_fn       = string_make("fn", 2);
	ctx.idn_for      = string_make("for", 3);
	ctx.idn_var      = string_make("var", 3);
	ctx.idn_nil      = string_make("nil", 3);
	ctx.idn_new      = string_make("new", 3);
	ctx.idn_case     = string_make("case", 4);
	ctx.idn_else     = string_make("else", 4);
	ctx.idn_enum     = string_make("enum", 4);
	ctx.idn_true     = string_make("true", 4);
	ctx.idn_break    = string_make("break", 5);
	ctx.idn_while    = string_make("while", 5);
	ctx.idn_false    = string_make("false", 5);
	ctx.idn_switch   = string_make("switch", 6);
	ctx.idn_struct   = string_make("struct", 6);
	ctx.idn_return   = string_make("return", 6);
	ctx.idn_continue = string_make("continue", 8);

	scope_push(SCOPE_GLOBAL);
	ctx.global = ctx.scope;
}

// ================================================================
// lexical scanner

// currently unrecognized: # $ ? \ `
var lextab [256]u8 = {
	tEOF, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tSPC, tEOL, tSPC, tINV, tSPC, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
//	      !     "     #     $     %     &     '
	tSPC, tBANG, tDQT, tMSC, tMSC, tPERCENT, tAMP, tSQT,
//	(     )     *     +     ,     -     .     /
	tOPAREN, tCPAREN, tSTAR, tPLUS, tCOMMA, tMINUS, tDOT, tSLASH,
//	0     1     2     3     4     5     6     7
	tNUM, tNUM, tNUM, tNUM, tNUM, tNUM, tNUM, tNUM,
//	8     9     :     ;     <     =     >     ?
	tNUM, tNUM, tCOLON, tSEMI, tLT, tASSIGN, tGT, tMSC,
//	@     A     B     C     D     E     F     G
	tAT,  tIDN, tIDN, tIDN, tIDN, tIDN, tIDN, tIDN,
//	H     I     J     K     L     M     N     O
	tIDN, tIDN, tIDN, tIDN, tIDN, tIDN, tIDN, tIDN,
//	P     Q     R     S     T     U     V     W
	tIDN, tIDN, tIDN, tIDN, tIDN, tIDN, tIDN, tIDN,
//	X     Y     Z     [     \     ]     ^     _
	tIDN, tIDN, tIDN, tOBRACK, tMSC, tCBRACK, tCARET, tIDN,
//	`     a     b     c     d     e     f     g
	tMSC, tIDN, tIDN, tIDN, tIDN, tIDN, tIDN, tIDN,
//	h     i     j     k     l     m     n     o
	tIDN, tIDN, tIDN, tIDN, tIDN, tIDN, tIDN, tIDN,
//	p     q     r     s     t     u     v     w
	tIDN, tIDN, tIDN, tIDN, tIDN, tIDN, tIDN, tIDN,
//	x     y     z     {     |     }     ~
	tIDN, tIDN, tIDN, tOBRACE, tPIPE, tCBRACE, tNOT, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
	tINV, tINV, tINV, tINV, tINV, tINV, tINV, tINV,
};

fn unhex(ch u32) i32 {
	if ((ch >= '0') && (ch <= '9')) {
		return ch - '0';
	}
	if ((ch >= 'a') && (ch <= 'f')) {
		return ch - 'a' + 10;
	}
	if ((ch >= 'A') && (ch <= 'F')) {
		return ch - 'A' + 10;
	}
	return -1;
}

fn scan() Token {
	var ch i32 = readc(0);
	if (ch < 0) {
		ctx.cc = 0;
	} else {
		ctx.cc = ch;
	}
	return ctx.cc;
}

fn unescape(n u32) u32 {
	if (n == 'n') {
		return 10;
	} else if (n == 'r') {
		return 13;
	} else if (n == 't') {
		return 9;
	} else if (n == '"') {
		return '"';
	} else if (n == '\'') {
		return '\'';
	} else if (n == '\\') {
		return '\\';
	} else if (n == 'x') {
		var x0 u32 = unhex(scan());
		var x1 u32 = unhex(scan());
		if ((x0 < 0) || (x1 < 0)) {
			error("invalid hex escape");
		}
		return (x0 << 4) | x1;
	} else {
		error("invalid escape ", n);
		return 0;
	}
}

fn scan_string(cc u32, nc u32) Token {
	var n u32 = 0;
	while (true) {
		if (nc == '"') {
			nc = scan();
			break;
		} else if (nc == 0) {
			error("unterminated string");
		} else if (nc == '\\') {
			ctx.tmp[n] = unescape(scan());
		} else {
			ctx.tmp[n] = nc;
		}
		nc = scan();
		n++;
		if (n == 255) {
			error("constant string too large");
		}
	}
	ctx.tmp[n] = 0;
	return tSTR;
}

fn scan_keyword(len u32) Token {
	ctx.tmp[len] = 0;
	var idn String = string_make(ctx.tmp, len);
	ctx.ident = idn;

	if (len == 2) {
		if (idn == ctx.idn_if) { return tIF; };
		if (idn == ctx.idn_fn) { return tFN; }
	} else if (len == 3) {
		if (idn == ctx.idn_for) { return tFOR; }
		if (idn == ctx.idn_var) { return tVAR; }
		if (idn == ctx.idn_nil) { return tNIL; }
		if (idn == ctx.idn_new) { return tNEW; }
	} else if (len == 4) {
		if (idn == ctx.idn_case) { return tCASE; }
		if (idn == ctx.idn_else) { return tELSE; }
		if (idn == ctx.idn_enum) { return tENUM; }
		if (idn == ctx.idn_true) { return tTRUE; }
	} else if (len == 5) {
		if (idn == ctx.idn_break) { return tBREAK; }
		if (idn == ctx.idn_while) { return tWHILE; }
		if (idn == ctx.idn_false) { return tFALSE; }
	} else if (len == 6) {
		if (idn == ctx.idn_switch) { return tSWITCH; }
		if (idn == ctx.idn_struct) { return tSTRUCT; }
		if (idn == ctx.idn_return) { return tRETURN; }
	} else if (len == 8) {
		if (idn == ctx.idn_continue) { return tCONTINUE; }
	}
	return tIDN;
}

fn scan_number(cc u32, nc u32) Token {
	var n u32 = 1;
	var val u32 = cc - '0';

	if ((cc == '0') && (nc == 'b')) { // binary
		nc = scan();
		while ((nc == '0') || (nc == '1')) {
			val = (val << 1) | (nc - '0');
			nc = scan();
			n++;
			if (n == 34) {
				error("binary constant too large");
			}
		}
	} else if ((cc == '0') && (nc == 'x')) { // hex
		nc = scan();
		while (true) {
			var tmp i32 = unhex(nc);
			if (tmp == -1) {
				break;
			}
			val = (val << 4) | tmp;
			nc = scan();
			n++;
			if (n == 10) {
				error("hex constant too large");
			}
		}
	} else { // decimal
		while (lextab[nc] == tNUM) {
			var tmp u32 = (val * 10) + (nc - '0');
			if (tmp <= val) {
				error("decimal constant too large");
			}
			val = tmp;
			nc = scan();
			n++;
		}
	}
	ctx.num = val;
	return tNUM;
}

fn scan_ident(cc u32, nc u32) Token {
	ctx.tmp[0] = cc;
	var n u32 = 1;

	while (true) {
		var tok Token = lextab[nc];
		if ((tok == tIDN) || (tok == tNUM)) {
			ctx.tmp[n] = nc;
			n++;
			if (n == 32) { error("identifier too large"); }
			nc = scan();
		} else {
			break;
		}
	}
	return scan_keyword(n);
}

fn _next() Token {
	var nc u8 = ctx.cc;
	while (1) {
		var cc u8 = nc;
		nc = scan();
		var tok Token = lextab[cc];
		if (tok == tNUM) { // 0..9
			return scan_number(cc, nc);
		} else if (tok == tIDN) { // _ A..Z a..z
			return scan_ident(cc, nc);
		} else if (tok == tDQT) { // "
			return scan_string(cc, nc);
		} else if (tok == tSQT) { // '
			ctx.num = nc;
			if (nc == '\\') {
				ctx.num = unescape(scan());
			}
			nc = scan();
			if (nc != '\'') {
				error("unterminated character constant");
			}
			nc = scan();
			return tNUM;
		} else if (tok == tPLUS) {
			if (nc == '+') { tok = tINC; nc = scan(); }
		} else if (tok == tMINUS) {
			if (nc == '-') { tok = tDEC; nc = scan(); }
		} else if (tok == tAMP) {
			if (nc == '&') { tok = tAND; nc = scan(); }
		} else if (tok == tPIPE) {
			if (nc == '|') { tok = tOR; nc = scan(); }
		} else if (tok == tGT) {
			if (nc == '=') { tok = tGE; nc = scan(); }
			else if (nc == '>') { tok = tRIGHT; nc = scan(); }
		} else if (tok == tLT) {
			if (nc == '=') { tok = tLE; nc = scan(); }
			else if (nc == '<') { tok = tLEFT; nc = scan(); }
		} else if (tok == tASSIGN) {
			if (nc == '=') { tok = tEQ; nc = scan(); }
		} else if (tok == tBANG) {
			if (nc == '=') { tok = tNE; nc = scan(); }
		} else if (tok == tSLASH) {
			if (nc == '/') {
				// comment -- consume until EOL or EOF
				while ((nc != '\n') && (nc != 0)) {
					nc = scan();
				}
				continue;
			}
		} else if (tok == tEOL) {
			ctx.linenumber++;
			ctx.lineoffset = ctx.byteoffset;
			//if (ctx.flags & cfVisibleEOL) {
			//	return tEOL;
			//}
			continue;
		} else if (tok == tSPC) {
			continue;
		} else if ((tok == tMSC) || (tok == tINV)) {
			error("unknown character 0x%02x", cc);
		}

		// if we're an AddOp or MulOp, followed by an '='
		if (((tok & 0xF0) == 0x20) && (nc == '=')) {
			nc = scan();
			// transform us to a XEQ operation
			tok = tok + 0x10;
		}

		return tok;
	}
}

fn token_printstr(fd i32) {
	var n u32 = 0;
	writec(fd, '"');
	while (n < 256) {
		var ch u32 = ctx.tmp[n];
		if (ch == 0) {
			break;
		} else if ((ch < ' ') || (ch > '~')) {
			writex(fd, ch);
		} else if ((ch == '"') || (ch == '\\')) {
			writec(fd, '\\');
			writec(fd, ch);
		} else {
			writec(fd, ch);
		}
		n++;
	}
	writec(fd, '"');
}

fn token_print(fd i32) {
	if (ctx.tok == tNUM) {
		writec(fd, '#');
		writex(fd, ctx.num);
	} else if (ctx.tok == tIDN) {
		writec(fd, '@');
		writes(fd, ctx.tmp);
	} else if (ctx.tok == tEOL) {
		writec(fd, '\n');
	} else if (ctx.tok == tSTR) {
		token_printstr(fd);
	} else {
		writes(fd, tnames[ctx.tok]);
	}
	writec(fd, ' ');
}

fn next() Token {
	ctx.tok = _next();
	return ctx.tok;
}

fn start() i32 {
	ctx_init();
	scan();
	
	while(next() != tEOF) {
		token_print(1);
	}
	writec(1, '\n');
	return 0;
}

